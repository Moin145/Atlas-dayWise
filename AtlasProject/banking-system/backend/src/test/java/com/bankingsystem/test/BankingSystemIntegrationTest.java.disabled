package com.bankingsystem.test;

import com.bankingsystem.model.Account;
import com.bankingsystem.model.Customer;
import com.bankingsystem.model.Transaction;
import com.bankingsystem.repository.AccountRepository;
import com.bankingsystem.repository.CustomerRepository;
import com.bankingsystem.repository.TransactionRepository;
import com.bankingsystem.service.DepositService;
import com.bankingsystem.service.WithdrawService;
import com.bankingsystem.service.TransferService;
import com.bankingsystem.service.AuditService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Timeout;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@DisplayName("Banking System Integration Tests")
@TestPropertySource(locations = "classpath:application-test.properties")
class BankingSystemIntegrationTest {

    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private AccountRepository accountRepository;
    
    @Autowired
    private TransactionRepository transactionRepository;
    
    @Autowired
    private DepositService depositService;
    
    @Autowired
    private WithdrawService withdrawService;
    
    @Autowired
    private TransferService transferService;
    
    @Autowired
    private AuditService auditService;

    private Customer testCustomer1;
    private Customer testCustomer2;
    private Account testAccount1;
    private Account testAccount2;
    private final String testUserId = "TEST_USER";

    @BeforeEach
    void setUp() {
        // Clean up existing test data
        transactionRepository.deleteAll();
        accountRepository.deleteAll();
        customerRepository.deleteAll();
        
        // Create test customers
        testCustomer1 = new Customer("Rajesh", "Kumar", "rajesh.kumar@test.com", 
                "9876543210", "123 MG Road", "Mumbai", "Maharashtra", "400001");
        testCustomer1.setPanNumber("ABCDE1234F");
        testCustomer1.setAadharNumber("123456789012");
        testCustomer1 = customerRepository.save(testCustomer1);
        
        testCustomer2 = new Customer("Priya", "Sharma", "priya.sharma@test.com", 
                "9876543211", "456 Brigade Road", "Bangalore", "Karnataka", "560001");
        testCustomer2.setPanNumber("FGHIJ5678K");
        testCustomer2.setAadharNumber("123456789013");
        testCustomer2 = customerRepository.save(testCustomer2);
        
        // Create test accounts
        testAccount1 = new Account("ACC" + System.currentTimeMillis() + "001", testCustomer1, Account.AccountType.SAVINGS);
        testAccount1.deposit(new BigDecimal("50000"));
        testAccount1 = accountRepository.save(testAccount1);
        
        testAccount2 = new Account("ACC" + System.currentTimeMillis() + "002", testCustomer2, Account.AccountType.CURRENT);
        testAccount2.deposit(new BigDecimal("30000"));
        testAccount2 = accountRepository.save(testAccount2);
    }

    @Nested
    @DisplayName("Customer Management Tests")
    class CustomerManagementTests {

        @Test
        @DisplayName("Should create customer successfully")
        void shouldCreateCustomerSuccessfully() {
            // Given
            Customer newCustomer = new Customer("Amit", "Patel", "amit.patel@test.com", 
                    "9876543212", "789 Park Street", "Kolkata", "West Bengal", "700016");
            newCustomer.setPanNumber("KLMNO9012P");
            newCustomer.setAadharNumber("123456789014");
            
            // When
            Customer savedCustomer = customerRepository.save(newCustomer);
            
            // Then
            assertThat(savedCustomer).isNotNull();
            assertThat(savedCustomer.getId()).isNotNull();
            assertThat(savedCustomer.getFirstName()).isEqualTo("Amit");
            assertThat(savedCustomer.getLastName()).isEqualTo("Patel");
            assertThat(savedCustomer.getEmail()).isEqualTo("amit.patel@test.com");
            assertThat(savedCustomer.getCity()).isEqualTo("Kolkata");
        }

        @Test
        @DisplayName("Should find customer by ID")
        void shouldFindCustomerById() {
            // When
            Optional<Customer> foundCustomer = customerRepository.findById(testCustomer1.getId());
            
            // Then
            assertThat(foundCustomer).isPresent();
            assertThat(foundCustomer.get().getFirstName()).isEqualTo("Rajesh");
            assertThat(foundCustomer.get().getLastName()).isEqualTo("Kumar");
        }

        @Test
        @DisplayName("Should find all customers")
        void shouldFindAllCustomers() {
            // When
            List<Customer> customers = customerRepository.findAll();
            
            // Then
            assertThat(customers).hasSize(2);
            assertThat(customers).extracting(Customer::getFirstName)
                    .containsExactlyInAnyOrder("Rajesh", "Priya");
        }
    }

    @Nested
    @DisplayName("Account Management Tests")
    class AccountManagementTests {

        @Test
        @DisplayName("Should create account successfully")
        void shouldCreateAccountSuccessfully() {
            // Given
            String accountNumber = "ACC" + System.currentTimeMillis() + "999";
            Account newAccount = new Account(accountNumber, testCustomer1, Account.AccountType.SAVINGS);
            
            // When
            Account savedAccount = accountRepository.save(newAccount);
            
            // Then
            assertThat(savedAccount).isNotNull();
            assertThat(savedAccount.getAccountNumber()).isEqualTo(accountNumber);
            assertThat(savedAccount.getAccountType()).isEqualTo(Account.AccountType.SAVINGS);
            assertThat(savedAccount.getCustomer().getId()).isEqualTo(testCustomer1.getId());
            assertThat(savedAccount.getBalance()).isEqualTo(BigDecimal.ZERO);
        }

        @Test
        @DisplayName("Should find account by account number")
        void shouldFindAccountByAccountNumber() {
            // When
            Optional<Account> foundAccount = accountRepository.findByAccountNumber(testAccount1.getAccountNumber());
            
            // Then
            assertThat(foundAccount).isPresent();
            assertThat(foundAccount.get().getAccountNumber()).isEqualTo(testAccount1.getAccountNumber());
            assertThat(foundAccount.get().getCustomer().getFirstName()).isEqualTo("Rajesh");
        }

        @Test
        @DisplayName("Should find accounts by customer")
        void shouldFindAccountsByCustomer() {
            // When
            List<Account> customerAccounts = accountRepository.findByCustomerId(testCustomer1.getId());
            
            // Then
            assertThat(customerAccounts).hasSize(1);
            assertThat(customerAccounts.get(0).getAccountNumber()).isEqualTo(testAccount1.getAccountNumber());
        }
    }

    @Nested
    @DisplayName("Deposit Tests")
    class DepositTests {

        @Test
        @DisplayName("Should deposit money successfully")
        void shouldDepositMoneySuccessfully() {
            // Given
            BigDecimal depositAmount = new BigDecimal("10000");
            String description = "Test deposit";
            
            // When
            Transaction transaction = depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    depositAmount, 
                    description, 
                    testUserId
            );
            
            // Then
            assertThat(transaction).isNotNull();
            assertThat(transaction.getType()).isEqualTo(Transaction.TransactionType.DEPOSIT);
            assertThat(transaction.getAmount()).isEqualTo(depositAmount);
            assertThat(transaction.getDescription()).isEqualTo(description);
            assertThat(transaction.getStatus()).isEqualTo(Transaction.TransactionStatus.COMPLETED);
            
            // Verify account balance updated
            Optional<Account> updatedAccount = accountRepository.findByAccountNumber(testAccount1.getAccountNumber());
            assertThat(updatedAccount).isPresent();
            assertThat(updatedAccount.get().getBalance()).isEqualTo(new BigDecimal("60000"));
        }

        @Test
        @DisplayName("Should fail deposit with invalid account")
        void shouldFailDepositWithInvalidAccount() {
            // Given
            String invalidAccountNumber = "INVALID_ACC";
            BigDecimal depositAmount = new BigDecimal("1000");
            String description = "Test deposit";
            
            // When & Then
            assertThatThrownBy(() -> depositService.processDeposit(
                    invalidAccountNumber, 
                    depositAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Account not found");
        }

        @Test
        @DisplayName("Should fail deposit with negative amount")
        void shouldFailDepositWithNegativeAmount() {
            // Given
            BigDecimal negativeAmount = new BigDecimal("-1000");
            String description = "Test deposit";
            
            // When & Then
            assertThatThrownBy(() -> depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    negativeAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(IllegalArgumentException.class);
        }
    }

    @Nested
    @DisplayName("Withdrawal Tests")
    class WithdrawalTests {

        @Test
        @DisplayName("Should withdraw money successfully")
        void shouldWithdrawMoneySuccessfully() {
            // Given
            BigDecimal withdrawalAmount = new BigDecimal("10000");
            String description = "Test withdrawal";
            
            // When
            Transaction transaction = withdrawService.processWithdrawal(
                    testAccount1.getAccountNumber(), 
                    withdrawalAmount, 
                    description, 
                    testUserId
            );
            
            // Then
            assertThat(transaction).isNotNull();
            assertThat(transaction.getType()).isEqualTo(Transaction.TransactionType.WITHDRAWAL);
            assertThat(transaction.getAmount()).isEqualTo(withdrawalAmount);
            assertThat(transaction.getStatus()).isEqualTo(Transaction.TransactionStatus.COMPLETED);
            
            // Verify account balance updated
            Optional<Account> updatedAccount = accountRepository.findByAccountNumber(testAccount1.getAccountNumber());
            assertThat(updatedAccount).isPresent();
            assertThat(updatedAccount.get().getBalance()).isEqualTo(new BigDecimal("40000"));
        }

        @Test
        @DisplayName("Should fail withdrawal with insufficient funds")
        void shouldFailWithdrawalWithInsufficientFunds() {
            // Given
            BigDecimal excessiveAmount = new BigDecimal("100000");
            String description = "Test withdrawal";
            
            // When & Then
            assertThatThrownBy(() -> withdrawService.processWithdrawal(
                    testAccount1.getAccountNumber(), 
                    excessiveAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Insufficient balance");
        }

        @Test
        @DisplayName("Should fail withdrawal with invalid account")
        void shouldFailWithdrawalWithInvalidAccount() {
            // Given
            String invalidAccountNumber = "INVALID_ACC";
            BigDecimal withdrawalAmount = new BigDecimal("1000");
            String description = "Test withdrawal";
            
            // When & Then
            assertThatThrownBy(() -> withdrawService.processWithdrawal(
                    invalidAccountNumber, 
                    withdrawalAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Account not found");
        }
    }

    @Nested
    @DisplayName("Transfer Tests")
    class TransferTests {

        @Test
        @DisplayName("Should transfer money successfully between accounts")
        void shouldTransferMoneySuccessfully() {
            // Given
            BigDecimal transferAmount = new BigDecimal("10000");
            String description = "Test transfer";
            
            // When
            Transaction transaction = transferService.processTransfer(
                    testAccount1.getAccountNumber(), 
                    testAccount2.getAccountNumber(), 
                    transferAmount, 
                    description, 
                    testUserId
            );
            
            // Then
            assertThat(transaction).isNotNull();
            assertThat(transaction.getType()).isEqualTo(Transaction.TransactionType.TRANSFER);
            assertThat(transaction.getAmount()).isEqualTo(transferAmount);
            assertThat(transaction.getStatus()).isEqualTo(Transaction.TransactionStatus.COMPLETED);
            
            // Verify both account balances updated
            Optional<Account> sourceAccount = accountRepository.findByAccountNumber(testAccount1.getAccountNumber());
            Optional<Account> destinationAccount = accountRepository.findByAccountNumber(testAccount2.getAccountNumber());
            
            assertThat(sourceAccount).isPresent();
            assertThat(destinationAccount).isPresent();
            assertThat(sourceAccount.get().getBalance()).isEqualTo(new BigDecimal("40000"));
            assertThat(destinationAccount.get().getBalance()).isEqualTo(new BigDecimal("40000"));
        }

        @Test
        @DisplayName("Should fail transfer with insufficient funds")
        void shouldFailTransferWithInsufficientFunds() {
            // Given
            BigDecimal excessiveAmount = new BigDecimal("100000");
            String description = "Test transfer";
            
            // When & Then
            assertThatThrownBy(() -> transferService.processTransfer(
                    testAccount1.getAccountNumber(), 
                    testAccount2.getAccountNumber(), 
                    excessiveAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Insufficient balance");
        }

        @Test
        @DisplayName("Should fail transfer to same account")
        void shouldFailTransferToSameAccount() {
            // Given
            BigDecimal transferAmount = new BigDecimal("1000");
            String description = "Test transfer";
            
            // When & Then
            assertThatThrownBy(() -> transferService.processTransfer(
                    testAccount1.getAccountNumber(), 
                    testAccount1.getAccountNumber(), 
                    transferAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("Cannot transfer to the same account");
        }

        @Test
        @DisplayName("Should fail transfer with invalid source account")
        void shouldFailTransferWithInvalidSourceAccount() {
            // Given
            String invalidSourceAccount = "INVALID_SOURCE";
            BigDecimal transferAmount = new BigDecimal("1000");
            String description = "Test transfer";
            
            // When & Then
            assertThatThrownBy(() -> transferService.processTransfer(
                    invalidSourceAccount, 
                    testAccount2.getAccountNumber(), 
                    transferAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Source account not found");
        }

        @Test
        @DisplayName("Should fail transfer with invalid destination account")
        void shouldFailTransferWithInvalidDestinationAccount() {
            // Given
            String invalidDestinationAccount = "INVALID_DEST";
            BigDecimal transferAmount = new BigDecimal("1000");
            String description = "Test transfer";
            
            // When & Then
            assertThatThrownBy(() -> transferService.processTransfer(
                    testAccount1.getAccountNumber(), 
                    invalidDestinationAccount, 
                    transferAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(RuntimeException.class)
              .hasMessageContaining("Destination account not found");
        }
    }

    @Nested
    @DisplayName("Transaction History Tests")
    class TransactionHistoryTests {

        @Test
        @DisplayName("Should record transaction history")
        void shouldRecordTransactionHistory() {
            // Given
            BigDecimal depositAmount = new BigDecimal("5000");
            String description = "Test deposit for history";
            
            // When
            depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    depositAmount, 
                    description, 
                    testUserId
            );
            
            // Then
            List<Transaction> transactions = transactionRepository.findByAccountNumber(testAccount1.getAccountNumber());
            assertThat(transactions).hasSize(1);
            assertThat(transactions.get(0).getType()).isEqualTo(Transaction.TransactionType.DEPOSIT);
            assertThat(transactions.get(0).getAmount()).isEqualTo(depositAmount);
            assertThat(transactions.get(0).getDescription()).isEqualTo(description);
        }

        @Test
        @DisplayName("Should find transactions by account number")
        void shouldFindTransactionsByAccountNumber() {
            // Given - Create multiple transactions
            depositService.processDeposit(testAccount1.getAccountNumber(), new BigDecimal("1000"), "Deposit 1", testUserId);
            depositService.processDeposit(testAccount1.getAccountNumber(), new BigDecimal("2000"), "Deposit 2", testUserId);
            withdrawService.processWithdrawal(testAccount1.getAccountNumber(), new BigDecimal("500"), "Withdrawal 1", testUserId);
            
            // When
            List<Transaction> transactions = transactionRepository.findByAccountNumber(testAccount1.getAccountNumber());
            
            // Then
            assertThat(transactions).hasSize(3);
            assertThat(transactions).extracting(Transaction::getType)
                    .containsExactlyInAnyOrder(
                            Transaction.TransactionType.DEPOSIT,
                            Transaction.TransactionType.DEPOSIT,
                            Transaction.TransactionType.WITHDRAWAL
                    );
        }
    }

    @Nested
    @DisplayName("Audit Logging Tests")
    class AuditLoggingTests {

        @Test
        @DisplayName("Should log successful deposit")
        void shouldLogSuccessfulDeposit() {
            // Given
            BigDecimal depositAmount = new BigDecimal("1000");
            String description = "Test deposit for audit";
            
            // When
            depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    depositAmount, 
                    description, 
                    testUserId
            );
            
            // Then - Verify audit log was created
            // Note: This would require checking the audit service or repository
            // The actual implementation depends on how audit logging is implemented
            assertThat(true).isTrue(); // Placeholder for audit verification
        }

        @Test
        @DisplayName("Should log failed transaction")
        void shouldLogFailedTransaction() {
            // Given
            String invalidAccount = "INVALID_ACC";
            BigDecimal amount = new BigDecimal("1000");
            
            // When & Then
            assertThatThrownBy(() -> depositService.processDeposit(
                    invalidAccount, 
                    amount, 
                    "Test deposit", 
                    testUserId
            )).isInstanceOf(RuntimeException.class);
            
            // Verify that failed transaction is also logged
            // This would depend on the audit implementation
            assertThat(true).isTrue(); // Placeholder for audit verification
        }
    }

    @Nested
    @DisplayName("Edge Cases and Error Handling")
    class EdgeCasesAndErrorHandlingTests {

        @Test
        @DisplayName("Should handle zero amount transactions")
        void shouldHandleZeroAmountTransactions() {
            // Given
            BigDecimal zeroAmount = BigDecimal.ZERO;
            String description = "Zero amount test";
            
            // When & Then
            assertThatThrownBy(() -> depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    zeroAmount, 
                    description, 
                    testUserId
            )).isInstanceOf(IllegalArgumentException.class);
        }

        @Test
        @DisplayName("Should handle very large amounts")
        void shouldHandleVeryLargeAmounts() {
            // Given
            BigDecimal largeAmount = new BigDecimal("999999999.99");
            String description = "Large amount test";
            
            // When
            Transaction transaction = depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    largeAmount, 
                    description, 
                    testUserId
            );
            
            // Then
            assertThat(transaction).isNotNull();
            assertThat(transaction.getAmount()).isEqualTo(largeAmount);
        }

        @Test
        @DisplayName("Should handle concurrent transactions")
        void shouldHandleConcurrentTransactions() {
            // This test would require more complex setup with threading
            // For now, we'll test that the basic functionality works
            BigDecimal amount1 = new BigDecimal("1000");
            BigDecimal amount2 = new BigDecimal("2000");
            
            // When
            Transaction transaction1 = depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    amount1, 
                    "Concurrent deposit 1", 
                    testUserId
            );
            
            Transaction transaction2 = depositService.processDeposit(
                    testAccount1.getAccountNumber(), 
                    amount2, 
                    "Concurrent deposit 2", 
                    testUserId
            );
            
            // Then
            assertThat(transaction1).isNotNull();
            assertThat(transaction2).isNotNull();
            
            // Verify final balance
            Optional<Account> updatedAccount = accountRepository.findByAccountNumber(testAccount1.getAccountNumber());
            assertThat(updatedAccount).isPresent();
            assertThat(updatedAccount.get().getBalance()).isEqualTo(new BigDecimal("53000"));
        }
    }
}